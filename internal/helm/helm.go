package helm

import (
	"context"
	"fmt"
	"io"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/ardikabs/helmize/internal/errs"
	"github.com/ardikabs/helmize/internal/util"
	"helm.sh/helm/v3/pkg/chart"
	"helm.sh/helm/v3/pkg/chart/loader"
	"helm.sh/helm/v3/pkg/cli"
	"helm.sh/helm/v3/pkg/cli/values"
	"helm.sh/helm/v3/pkg/getter"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/yaml"
)

var settings = cli.New()

type DefaultHelmRenderer struct {
	writer    io.Writer
	client    *clientFactory
	repo      HelmRepo
	isOCIRepo bool
}

func NewHelmRenderer(writer io.Writer, helmRepo HelmRepo) (*DefaultHelmRenderer, error) {
	r := &DefaultHelmRenderer{
		writer: writer,
		client: newClientFactory(),
		repo:   helmRepo,
	}

	return r, nil
}

type RenderParameter struct {
	ReleaseName           string
	ReleaseNamespace      string
	ChartName             string
	Version               string
	Values                []string
	ValuesInline          map[string]interface{}
	IncludeCRDs           bool
	CreateNamespace       bool
	InsecureSkipVerifyTLS bool
	IgnoreDeprecatedChart bool
}

func (r DefaultHelmRenderer) Render(ctx context.Context, param RenderParameter) error {
	client := r.client.GetClient(
		WithInsecureSkipVerifyTLS(param.InsecureSkipVerifyTLS),
		WithIncludeCRDs(param.IncludeCRDs),
		WithChartVersion(param.Version),
		WithReleaseName(param.ReleaseName),
		WithReleaseNamespace(param.ReleaseNamespace),
	)

	if err := r.repo.Init(ctx, client); err != nil {
		return err
	}

	if param.CreateNamespace {
		ns := &corev1.Namespace{
			TypeMeta: metav1.TypeMeta{
				APIVersion: "v1",
				Kind:       "Namespace",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name: param.ReleaseNamespace,
				Labels: map[string]string{
					"name": param.ReleaseNamespace,
				},
			},
		}

		buf, err := yaml.Marshal(ns)
		if err != nil {
			return fmt.Errorf("%w; %v", errs.ErrInternal, err)
		}

		if _, err := r.writer.Write([]byte(fmt.Sprintf("---\n# Source: Generated by Helmize \n%s", string(buf)))); err != nil {
			return fmt.Errorf("%w; %v", errs.ErrInternal, err)
		}
	}

	nameAndChart, err := r.repo.NameAndChart(param.ChartName)
	if err != nil {
		return err
	}

	chartLocation, err := client.LocateChart(nameAndChart, settings)
	if err != nil {
		return fmt.Errorf("%w; %v", errs.ErrRender, err)
	}

	valuesOpts := new(values.Options)
	for _, v := range param.Values {
		matches, err := filepath.Glob(v)
		if err != nil {
			continue
		}

		valuesOpts.ValueFiles = append(valuesOpts.ValueFiles, matches...)
	}

	if param.ValuesInline != nil {
		b, err := yaml.Marshal(param.ValuesInline)
		if err != nil {
			return fmt.Errorf("%w; %v", errs.ErrInternal, err)
		}

		filename, err := util.WriteTempValues(param.ReleaseName, b)
		if err != nil {
			return fmt.Errorf("%w; %v", errs.ErrInternal, err)
		}
		defer os.RemoveAll(path.Dir(filename))

		valuesOpts.ValueFiles = append(valuesOpts.ValueFiles, filename)
	}

	p := getter.All(settings)
	vals, err := valuesOpts.MergeValues(p)
	if err != nil {
		return fmt.Errorf("%w; %v", errs.ErrRender, err)
	}

	chartRequested, err := loader.Load(chartLocation)
	if err != nil {
		return fmt.Errorf("%w; %v", errs.ErrRender, err)
	}

	if err := isChartInstallable(chartRequested); err != nil {
		return fmt.Errorf("%w; %v", errs.ErrRender, err)
	}

	if chartRequested.Metadata.Deprecated && !param.IgnoreDeprecatedChart {
		return fmt.Errorf("%w; Chart %s is deprecated!", errs.ErrRender, chartRequested.Metadata.Name)
	}

	helmRelease, err := client.Run(chartRequested, vals)
	if err != nil {
		return fmt.Errorf("%w; %v", errs.ErrRender, err)
	}

	if _, err := r.writer.Write([]byte(strings.TrimSpace(helmRelease.Manifest))); err != nil {
		return fmt.Errorf("%w; %v", errs.ErrInternal, err)
	}

	return nil
}

func isChartInstallable(ch *chart.Chart) error {
	switch ch.Metadata.Type {
	case "", "application":
		return nil
	}
	return fmt.Errorf("Chart %s is not installable type, (%s)", ch.Metadata.Name, ch.Metadata.Type)
}
